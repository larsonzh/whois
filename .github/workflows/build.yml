name: build-and-artifact

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*.*.*' ]
  pull_request:
  release:
    types: [published, edited]
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag name to release (e.g. v3.2.5)"
        required: false
        type: string

# Ensure the workflow token can create releases
permissions:
  contents: write

jobs:
  build-linux:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show workspace
        run: |
          pwd
          ls -la
          echo "::group::Makefile (head)" && sed -n '1,120p' Makefile || true && echo "::endgroup::"
          echo "::group::Tree (depth=2)" && find . -maxdepth 2 -type f | sort && echo "::endgroup::"

      - name: Toolchain info
        run: |
          gcc --version || true
          make -v || true

      - name: Build
        run: |
          set -xeuo pipefail
          make

      - name: Rename CI binary (x86_64 glibc)
        run: |
          test -f whois-client
          mv whois-client whois-x86_64-gnu

      - name: Show binary
        run: |
          file whois-x86_64-gnu || true
          ls -l whois-x86_64-gnu || true

      - name: Checksums
        run: |
          test -f whois-x86_64-gnu
          sha256sum whois-x86_64-gnu > SHA256SUMS.txt

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: whois-build-${{ github.sha }}
          path: |
            whois-x86_64-gnu
            SHA256SUMS.txt

  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show workspace
        run: |
          pwd
          ls -la
          echo "::group::Makefile (head)" && sed -n '1,120p' Makefile || true && echo "::endgroup::"
          echo "::group::Tree (depth=2)" && find . -maxdepth 2 -type f | sort && echo "::endgroup::"

      - name: Toolchain info
        run: |
          gcc --version || true
          make -v || true

      - name: Build
        run: |
          set -xeuo pipefail
          make

      - name: Resolve tag name (supports push tag, release event, manual dispatch)
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          TAG=""
          if [ "${{ github.event_name }}" = "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
          elif [ "${{ github.ref_type }}" = "tag" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            TAG="${{ github.ref_name }}"
          elif [ -n "${{ inputs.tag }}" ]; then
            TAG="${{ inputs.tag }}"
          fi
          if [ -z "$TAG" ]; then echo "No tag context available" >&2; exit 1; fi
          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then echo "Tag '$TAG' does not look like vX.Y.Z" >&2; exit 1; fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "TAG=$TAG" >> "$GITHUB_ENV"

      - name: Rename CI binary (x86_64 glibc)
        run: |
          test -f whois-client
          mv whois-client whois-x86_64-gnu

      - name: Prepare release_assets folder and add CI binary
        run: |
          set -xeuo pipefail
          mkdir -p release_assets
          mv -v whois-x86_64-gnu release_assets/

      # Collect 7 static binaries from local repo only (release/lzispro/whois)
      - name: Collect 7 static binaries (local only)
        run: |
          set -xeuo pipefail
          SRC="release/lzispro/whois"
          echo "-- Listing candidate root --"
          ls -la "$SRC" || echo "Static bin source not found: $SRC"
          for f in \
            whois-aarch64 \
            whois-armv7 \
            whois-x86_64 \
            whois-x86 \
            whois-mipsel \
            whois-mips64el \
            whois-loongarch64; do
            if [ -f "$SRC/$f" ]; then
              cp -v "$SRC/$f" release_assets/
            else
              echo "Warn: $SRC/$f not found, skip"
            fi
          done

      - name: Build combined SHA256SUMS
        run: |
          set -xeuo pipefail
          (cd release_assets && sha256sum * ) > SHA256SUMS.txt

      - name: Checksums
        run: |
          # Keep top-level SHA256SUMS for backward compatibility
          test -f SHA256SUMS.txt || (cd release_assets && sha256sum * ) > SHA256SUMS.txt

      - name: Choose release body file (prefer versioned body over RELEASE_NOTES)
        id: body
        shell: bash
        run: |
          set -euo pipefail
          CAND="docs/release_bodies/${{ steps.vars.outputs.tag }}.md"
          if [ -f "$CAND" ]; then echo "path=$CAND" >> "$GITHUB_OUTPUT"; else echo "path=RELEASE_NOTES.md" >> "$GITHUB_OUTPUT"; fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.vars.outputs.tag }}
          tag_name: ${{ steps.vars.outputs.tag }}
          generate_release_notes: false
          body_path: ${{ steps.body.outputs.path }}
          files: |
            release_assets/*
            SHA256SUMS.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish release to Gitee (links only)
        if: startsWith(steps.vars.outputs.tag, 'v')
        env:
          GITEE_OWNER: ${{ secrets.GITEE_OWNER }}
          GITEE_REPO:  ${{ secrets.GITEE_REPO }}
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          # Optional: allow overriding target commitish for creating tag on Gitee
          # If not provided, fallback to 'master'. This is required by Gitee API when the tag doesn't exist yet.
          GITEE_TARGET_COMMITISH: "${{ secrets.GITEE_TARGET_COMMITISH }}"
          TAG: ${{ steps.vars.outputs.tag }}
          REPO_FULL: ${{ github.repository }}
        run: |
          set -euo pipefail
          if [ -z "${GITEE_TOKEN:-}" ] || [ -z "${GITEE_OWNER:-}" ] || [ -z "${GITEE_REPO:-}" ]; then
            echo "Gitee secrets not set; skipping Gitee publish." && exit 0
          fi

          base="https://github.com/${REPO_FULL}/releases/download/${TAG}"
          target_commitish="${GITEE_TARGET_COMMITISH:-master}"

          # Collect present assets
          files=()
          if [ -d release_assets ]; then
            while IFS= read -r -d '' f; do
              files+=("$(basename "$f")")
            done < <(find release_assets -maxdepth 1 -type f -print0)
          fi
          # Also include top-level SHA256SUMS.txt when present
          if [ -f SHA256SUMS.txt ]; then
            files+=("SHA256SUMS.txt")
          fi

          # Build Gitee release body: reuse RELEASE_NOTES.md + append links for present files
          # Pick the same body used for GitHub, fallback to RELEASE_NOTES.md if missing
          BODY_PATH="${{ steps.body.outputs.path }}"
          cp "$BODY_PATH" gitee_body.md
          echo "" >> gitee_body.md
          echo "## Downloads (mirror)" >> gitee_body.md
          for f in "${files[@]}"; do
            echo "- ${base}/${f}" >> gitee_body.md
          done

          # Create Gitee release (best-effort). If it already exists, just warn and continue.
          resp=$(curl -sS -w "\n%{http_code}" -X POST "https://gitee.com/api/v5/repos/${GITEE_OWNER}/${GITEE_REPO}/releases" \
            --data-urlencode "access_token=${GITEE_TOKEN}" \
            --data-urlencode "tag_name=${TAG}" \
            --data-urlencode "name=${TAG}" \
            --data-urlencode "target_commitish=${target_commitish}" \
            --data-urlencode "body@./gitee_body.md") || true
          body=$(echo "$resp" | head -n -1 || true)
          code=$(echo "$resp" | tail -n1 || true)
          echo "Gitee create release HTTP $code"
          if [ "${code}" != "201" ] && [ "${code}" != "200" ]; then
            echo "Warn: failed to create Gitee release (code=${code}). Response:" && echo "$body"
            echo "Skip Gitee publish (non-blocking)."
          fi
